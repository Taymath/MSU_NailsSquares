#include <iostream>
#include "Test.h"
#include <random>
#include <fstream>
#include <iostream>

ofstream fout("D:\\MSU\\Coding\\sq\\diagram.csv");


void Test::save_results(TestResultsExtended &test_results, TaskResults &task_results)
{
    test_results.average_total_time += task_results.total_time;
    test_results.average_step_time += task_results.step_time;
    test_results.average_steps += task_results.steps;
    test_results.average_error_amount += task_results.error_amount;
    test_results.average_points += task_results.points.size();
    test_results.task_results.push_back(task_results);
}


void Test::conclude_average(TestResultsExtended &test_results)
{
    test_results.average_total_time /= test_data.tests_amount;
    test_results.average_step_time /= test_data.tests_amount;
    test_results.average_steps /= test_data.tests_amount;
    test_results.average_points /= test_data.tests_amount;
    test_results.average_error_amount /= test_data.tests_amount;
}
bool Test::belong(const Point &point, const Square &square)
{
     if(((point.x > square.left_corner.x) && (point.x < square.left_corner.x + test_data.side_length)) && ((point.y > square.left_corner.y) && (point.y < square.left_corner.y + test_data.side_length)))
         return true;
     else
         return false;
}

//тривиальный тест
void Test::simple_test()
{
    vector<Square> squares;

    test_data.tests_amount = 1;
    test_data.side_length = 1;

    squares.push_back(Square{false, {2 , 0.5}});
    squares.push_back(Square{false, {0.5 , 0.5}});
    squares.push_back(Square{false, {0 , 1}});
    squares.push_back(Square{false, {1 , 1}});
    squares.push_back(Square{false, {2 , 2}});
    squares.push_back(Square{false, {1.5 , 2.5}});
    squares.push_back(Square{false, {1 , 3}});
    squares.push_back(Square{false, {2 , 4}});
    squares.push_back(Square{false, {1.5 , 3.5}});
    squares.push_back(Square{false, {0.5 , 3}});

    task = new Task(TaskData{1, squares});

    task->res.steps = 0;
    task->res.points.clear();
    task->res.points.reserve(squares.size());

    clock_t start, end = 0;

    start = clock();

    task->complex_version();

    end = clock();

    check_point(squares, task->res.points);

    for(int i = 0; i < task->res.points.size() ; i ++)
    {
        cout<<"Point: " << task->res.points.at(i).x <<" "<< task->res.points.at(i).y << "\n";
    }

    task->res.total_time = (double)(end - start) / CLOCKS_PER_SEC;
    task->res.step_time = task->res.total_time / (double)task->res.steps;

    save_results(results.first, task->res);
    save_results(results.second, task->res);

    squares.clear();
    delete task;
}

void Test::random_test_algorithm()
{
    std::random_device rd;  // Для рандомной генерации
   // unsigned int seed = 1; //Для фиксированной генерации?
    std::mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()

   // gen.seed(15);//Для фиксированной генерации?

    std::uniform_real_distribution<> dis(1, 500);
    vector<Square> squares;


    for(int i = 0; i < test_data.tests_amount; i ++)
    {
        cout << "Test N" << i <<"\n";

        for (int j = 0; j < test_data.squares_amount; ++j)
            squares.push_back(Square{false, {dis(gen) , dis(gen)}});
        // Use dis to transform the random unsigned int generated by gen into a
        // double in [1, 500). Each call to dis(gen) generates a new random double.

        task = new Task(TaskData{test_data.side_length, squares});
        //первый алгоритм

        task->res.steps = 0;
        task->res.points.clear();
        task->res.points.reserve(squares.size());

        clock_t start, end = 0;

        for(auto & square : squares)
            square.covered = false;

        start = clock();

        task->simple_version();

        end = clock();

       if(i == 0)
            check_point(squares, task->res.points);

        task->res.total_time = (double)(end - start) / CLOCKS_PER_SEC;
        task->res.step_time = task->res.total_time / (double)task->res.steps;

        save_results(results.first, task->res);

        delete task;


        //второй алгоритм
        task = new Task(TaskData{test_data.side_length, squares});

        start = 0, end = 0;

        task->res.steps = 0;
        task->res.points.clear();
        task->res.points.reserve(squares.size());

        for(auto & square : squares)
            square.covered = false;

        start = clock();

        task->complex_version();

        end = clock();

        check_point(squares, task->res.points);

        task->res.total_time = (double)(end - start) / CLOCKS_PER_SEC;
        task->res.step_time = task->res.total_time / (double)task->res.steps;

        save_results(results.second, task->res);

        squares.clear();
        delete task;
    }

    conclude_average(results.first);
    conclude_average(results.second);
}

void Test::algorithm_results_console_print()
{
    if(test_data.tests_amount != 1)
    {
        cout << "||||||||||||||||||||" <<"\n";
        cout << " Tests amount: "<< test_data.tests_amount << "\n";
        cout << "Squares amount: " << test_data.squares_amount << "\n";
        cout << "Side length: " << test_data.side_length << "\n";

        for (int i = 0; i < test_data.tests_amount; i++)
        {
            cout << "\n TEST " << i << "\n";
                cout << "\n Simple Algorithm: "<< endl;
                cout << "Total time" << results.first.task_results.at(i).total_time << "\n";
                cout << "Time for step:" << results.first.task_results.at(i).step_time << "\n";
                cout << "Steps amount:" << results.first.task_results.at(i).steps << "\n";
                cout << "Points amount: " << results.first.task_results.at(i).points.size() << "\n";
                cout << "Errors amount: " << results.first.task_results.at(i).error_amount << "\n";

                cout << "\n Complex Algorithm: "<< endl;
                cout << "Total time" << results.second.task_results.at(i).total_time << "\n";
                cout << "Time for step:" << results.second.task_results.at(i).step_time << "\n";
                cout << "Steps amount:" << results.second.task_results.at(i).steps << "\n";
                cout << "Points amount: " << results.second.task_results.at(i).points.size() << "\n";
                cout << "Errors amount: " << results.second.task_results.at(i).error_amount << "\n";
        }
        cout << "\nSimple Algorithm: " << endl;
        cout << "\n Average total time:" << results.first.average_total_time << "\n";
        cout << "Average time for step:"<< results.first.average_step_time << "\n";
        cout << "Average steps amount:" << results.first.average_steps << "\n";
        cout << "Average points amount:" << results.first.average_points << "\n";
        cout << "Average errors amount:" << results.first.average_error_amount << "\n";

        cout << "\nComplex Algorithm: "<< endl;
        cout << "\n Average total time:" << results.second.average_total_time << "\n";
        cout << "Average time for step:"<< results.second.average_step_time << "\n";
        cout << "Average steps amount:" << results.second.average_steps << "\n";
        cout << "Average points amount:" << results.second.average_points << "\n";
        cout << "Average errors amount:" << results.second.average_error_amount << "\n";
    }
    else
    {
        cout << "TEST " << "\n";
        cout << "\nSimple Algorithm: " << endl;
        cout << "Total time" << results.first.task_results.at(0).total_time << "\n";
        cout << "Time for step:" << results.first.task_results.at(0).step_time << "\n";
        cout << "Steps amount:" << results.first.task_results.at(0).steps << "\n";
        cout << "Points amount: " << results.first.task_results.at(0).points.size() << "\n";

        cout << "\nComplex Algorithm: " << endl;
        cout << "Total time" << results.second.task_results.at(0).total_time << "\n";
        cout << "Time for step:" << results.second.task_results.at(0).step_time << "\n";
        cout << "Steps amount:" << results.second.task_results.at(0).steps << "\n";
        cout << "Points amount: " << results.second.task_results.at(0).points.size() << "\n";

        test_data.tests_amount = tests;
    }
}

void Test::increase_random_test(unsigned int increase_squares, unsigned int step)
{
    fout << "Side length; Squares amount; Total time Simple; Total time Complex;  Steps amount Simple; Steps amount Complex; Time/step Simple; Time/step Complex; Complexity Simple; Complexity Complex" << endl;
    while (test_data.squares_amount <= increase_squares)
    {
        cout << "\n NEW TESTS with " << test_data.squares_amount << " squares"<< endl;

        random_test_algorithm();
        algorithm_results_console_print();
        algorithm_results_csv_print();

        results.first.average_step_time = 0;
        results.first.average_steps = 0;
        results.first.average_total_time = 0;
        results.first.average_points = 0;
        results.first.squares_amount = 0;
        results.first.average_error_amount = 0;

        results.second.average_step_time = 0;
        results.second.average_steps = 0;
        results.second.average_total_time = 0;
        results.second.average_points = 0;
        results.second.squares_amount = 0;
        results.second.average_error_amount = 0;

        test_data.squares_amount += step;

    }
}
void Test::algorithm_results_csv_print()
{
    double complexity1 = 1.0 * test_data.squares_amount;
    double complexity2 = 1.0 * test_data.squares_amount*(log2(test_data.squares_amount));

    fout << test_data.side_length << ";"<< test_data.squares_amount << ";"<< results.first.average_total_time << ";"<< results.second.average_total_time << ";"
    <<results.first.average_steps << ";"<< results.second.average_steps << ";" << results.first.average_step_time << ";" << results.second.average_step_time <<";"<< complexity1 << ";" << complexity2 << ";" << endl;
}


void Test::check_point(const vector<Square> &squares, const vector<Point> &points)
{
    for (auto &square: squares)
    {
        bool result = false;

        for (auto &point: points)
                if (belong(point, square))
                {
                    //result = !result;

               //     if(!result)
                 //   {
                        task->res.error_amount++;
                      //  break;
                   // }
                }


    }
}



